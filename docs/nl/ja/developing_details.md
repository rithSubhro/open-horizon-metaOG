---

copyright:
years: 2021
lastupdated: "2021-02-20"

---

{:new_window: target="blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:child: .link .ulchildlink}
{:childlinks: .ullinks}

# 開発の詳細
{: #developing}

ここでは、ソフトウェア開発の慣例および {{site.data.keyword.edge_notm}} ({{site.data.keyword.edge_abbr}}) 開発の概念について詳しく説明します。
{:shortdesc}

## 概要
{: #developing_intro}

{{site.data.keyword.edge_notm}} ({{site.data.keyword.edge_abbr}}) は、[Open Horizon ](https://www.lfedge.org/projects/openhorizon/)オープンソース・ソフトウェアに基づいて作成されています。

{{site.data.keyword.ieam}} を使用して、エッジ・マシン用の任意のサービス・コンテナーを開発できます。 次いで、コンテナー構成に暗号的に署名し、それを公開できます。最後に、ソフトウェアのインストール、モニター、および更新を制御するためのデプロイメント・ポリシーまたはパターンを使用して、サービス・コンテナーをデプロイできます。これらのタスクを完了すると、{{site.data.keyword.horizon_agents}}および {{site.data.keyword.horizon_agbots}} がソフトウェア・ライフサイクルの管理についてコラボレーションするという合意を形成していることを確認できます。 これらのコンポーネントは、{{site.data.keyword.edge_nodes}}上のソフトウェア・ライフサイクルの詳細を自律的に管理します。{{site.data.keyword.ieam}} では、ポリシーを使用して機械学習モデルを自律的にデプロイすることもできます。機械学習モデルのデプロイメントについて詳しくは、[モデル管理システム](model_management_system.md)を参照してください。

{{site.data.keyword.ieam}} 内でのソフトウェア開発プロセスでは、システムのセキュリティーおよび保全性を維持することに重点が置かれる一方、エッジ・ノード上のアクティブなソフトウェアの管理に必要な作業は大幅に簡略化されます。 {{site.data.keyword.ieam}} の公開プロシージャーをビルドして、連続的な統合およびデプロイメントのパイプラインに組み込むことができます。 分散自律型エージェントが、ソフトウェアまたはポリシー ({{site.data.keyword.edge_deploy_pattern}}またはデプロイメント・ポリシー内など) に対して公開された変更を検出すると、自律型エージェントは独立して動作し、エッジ・マシンすべてにわたって (マシンがどこにあっても) ソフトウェアを更新して、ポリシーを適用することができます。

## サービス
{: #services_deploy_patterns}

{{site.data.keyword.edge_services}}は、エッジ・ソリューションのビルディング・ブロックです。各サービスには 1 つ以上の Docker コンテナーが含まれます。各 Docker コンテナーは、1 つ以上の長時間実行プロセスを含むことができます。 これらのプロセスは、ほとんどすべてのプログラミング言語で作成でき、任意のライブラリーまたはユーティリティーを使用できます。 ただし、これらのプロセスは、Docker コンテナーのコンテキストで開発され、実行される必要があります。 この柔軟性は、{{site.data.keyword.ieam}} が管理できるコードには、ほとんど制約がないことを意味します。 コンテナーが実行されると、そのコンテナーはセキュアなサンドボックス内に閉じ込められます。 このサンドボックスは、ハードウェア・デバイス、いくつかのオペレーティング・システム・サービス、ホスト・ファイル・システム、ホスト・エッジ・マシン・ネットワーク、およびエッジ・ノードで稼働する他のほとんどの重要なサービスに対するアクセスを制限します。 サンドボックス制約について詳しくは、『[サンドボックス](#sandbox)』を参照してください。

`cpu2evtstreams` サンプル・コードは、他の 2 つのエッジ・サービスを使用する 1 つの Docker コンテナーからなります。 これらのエッジ・サービスは、ローカルのプライベート Docker 仮想ネットワークを介して、HTTP REST API を使用して接続されています。 これらのサービスの名前は、`cpu` と `gps` です。 エージェントは、各サービスを、そのサービスへの依存関係を宣言した各サービスと共に、別々のプライベート・ネットワークにデプロイします。 `cpu2evtstreams` と `cpu` のために 1 つのネットワークが作成され、`cpu2evtstreams` と `gps` のために別のネットワークが作成されます。 このデプロイメントに 4 番目のサービスがあり、それも `cpu` サービスを共有しているとすると、`cpu` と 4 番目のサービスのためにのみ、もう 1 つのプライベート・ネットワークが作成されます。 {{site.data.keyword.ieam}} では、このネットワーク戦略によって、サービスのアクセスは、他のサービスが公開されたときに `requiredServices` にリストされている他のサービスのみに制限されます。 以下の図は、パターンがエッジ・ノードで実行されるときの `cpu2evtstreams` デプロイメントを示しています。

<img src="../images/edge/07_What_is_an_edge_node.svg" style="margin: 3%" alt="パターンのサービス">

注: IBM Event Streams のセットアップは一部のサンプルでのみ必要です。

2 つの仮想ネットワークにより、`cpu2evtstreams` サービス・コンテナーは、`cpu` サービス・コンテナーおよび `gps` サービス・コンテナーによって提供される REST API にアクセスできるようになっています。 これら 2 つのコンテナーは、オペレーティング・システム・サービスおよびハードウェア・デバイスへのアクセスを管理します。 REST API が使用されていますが、複数のサービスでのデータおよびコントロールの共有を可能にするために使用できる、その他の多くの通信形式があります。

多くの場合、エッジ・ノード向けの最も効率的なコーディング・パターンでは、独立して構成可能かつデプロイ可能な複数の小さなサービスがデプロイされます。 例えば、IoT パターンには、多くの場合、エッジ・ノード・ハードウェア (センサーやアクチュエーターなど) へのアクセスを必要とする下位サービスが含まれます。 これらのサービスは、他のサービスが使用できるように、このハードウェアへの共有アクセスを提供します。

このパターンは、有用な機能を提供するためにハードウェアが排他的アクセスを必要とする場合に役立ちます。 下位サービスは、このアクセスを適切に管理できます。 `cpu` サービス・コンテナーおよび `gps` サービス・コンテナーの役割は、基本的にはホストのオペレーティング・システム内のデバイス・ドライバー・ソフトウェアの役割に似ていますが、ただし、より高いレベルでのことです。 コードを分割して、独立した小さなサービス (一部は、ハードウェア・アクセス専門の下位サービス) にすると、問題点を明確に切り分けることができます。 各コンポーネントは自由に進化でき、現場で個別に更新できます。 また、サード・パーティー・アプリケーションを、それらが特定のハードウェアまたは他のサービスにアクセスすることを選択的に許可することによって、お客様専有の従来型の組み込みソフトウェア・スタックと一緒に安全にデプロイすることもできます。

例として、電力消費センサーをモニターするための 1 つの下位サービスとその他の下位サービスから構成される、製造コントローラーのデプロイメントを考えてみましょう。 それらの他の下位サービスは、モニターされるデバイスの電源操作のためのアクチュエーターの制御を有効にするために使用できます。 このデプロイメントに、センサーおよびアクチュエーターのサービスをコンシュームする、別の最上位サービス・コンテナーを含めることもできます。 この最上位サービスは、それらのサービスを使用して、オペレーターにアラートを出したり、異常な電力消費計測値が検出されたら自動的にデバイスの電源を切ったりすることができます。 また、このデプロイメントには、センサーおよびアクチュエーターのデータを記録して保存し、データに関する分析も実行できるような、履歴サービスを含めることもできます。 このようなデプロイメントに有用だと思われるその他のコンポーネントとして、GPS ロケーション・サービスがあります。

この設計では、個々のサービス・コンテナーを個別にバージョン管理および更新することができます。 コード変更を行うことなく、個々のサービスを再構成して他の有用なデプロイメントに組み入れることもできます。 必要な場合、サード・パーティー分析サービスをデプロイメントに追加できます。 このサード・パーティー・サービスには読み取り専用 API の特定セットのみへのアクセス権を付与することができ、このサービスがプラットフォーム上のアクチュエーターと対話することを防ぎます。

あるいは、この製造コントローラー例のすべてのタスクを単一のサービス・コンテナー内で実行することもできます。 この代替方法は通常は最善の手法ではありません。なぜなら、相互に接続された独立した小さなサービスの集合を使用するほうが、ソフトウェアの更新が速くなり、柔軟性が増すためです。 現場では小さなサービスの集合のほうがより強固でもあります。 デプロイメントの設計方法について詳しくは、[エッジ・ネイティブ開発プラクティス](best_practices.md)を参照してください。

## サンドボックス
{: #sandbox}

デプロイメントの実行場所となるサンドボックスは、他のサービス・コンテナーによって提供される API へのアクセスを制限します。 サービスは、明示的にサービスへの依存関係を示している場合のみアクセスを許可されます。 ホスト上のその他のプロセスは、これらのサービスにアクセスすることはできません。同様に、他のリモート・ホストはご使用のサービスのどれにもアクセスできません。ただし、サービスがホストの外部ネットワーク・インターフェースにポートを明示的に公開している場合を除きます。これらのサンドボックスのアクセス制御の制限は、管理されたアクセス制御リストではなく、ネットワークのアドレス可能度によって決められます。これは、各サービスの仮想ネットワークを作成することで実施され、通信を許可されているサービス・コンテナーのみが同じネットワークに接続されます。これにより、各エッジ・ノードでアクセス制御を構成する必要性が減ります。

## 他のサービスを使用するサービス
{: #using_services}

多くの場合、エッジ・サービスは、他のエッジ・サービスによって提供されるさまざまな API インターフェースを使用して、他のエッジ・サービスからデータを入手したり、それらに制御コマンドを送付したりします。 これらの API インターフェースは、`cpu2evtstreams` サンプルの下位サービス `cpu` および `gps` によって提供されているように、HTTP REST API であるのが一般的です。 ただし、これらのインターフェースは実際には、任意のもの (例えば、共有メモリー、TCP、または UDP) にすることができ、暗号化の有無も任意です。 これらの通信は、通常、単一のエッジ・ノード内で行われ、メッセージがこのホストを離れることはないため、ほとんどの場合は暗号化は不要です。

REST API の代わりに、パブリッシュ/サブスクライブのインターフェース (例えば、MQTT によって提供されるインターフェース) を使用できます。 データを断続的にしか提供しないサービスの場合、REST API はタイムアウトになる可能性があるため、通常はパブリッシュ/サブスクライブのインターフェースのほうが REST API を繰り返しポーリングするよりも単純です。 例として、ハードウェア・ボタンをモニターし、ボタン押下が発生したかどうかを他のサービスが検出できるように API を提供するサービスを考えてみましょう。 REST API が使用される場合、呼び出し元はその REST API を呼び出し、ボタンが押されたときに生じる応答を待てばいいわけではありません。 ボタンが押されないまま長時間経過すると、REST API はタイムアウトになります。 代わりに、エラーを回避するために、API の提供側が即時に応答することが必要になります。 呼び出し元は、短いボタン押下を見逃さないために、繰り返し、頻繁に API を呼び出さなければなりません。 より良い解決方法は、呼び出し元が、パブリッシュとサブスクライブを行うサービスおよびブロックに対して適切なトピックをサブスクライブすることです。 そうすると、呼び出し元は何かがパブリッシュされるのを待つことができ、それはずっと先に起こる可能性があります。 API の提供側では、ボタン・ハードウェアをモニターし、そのトピックの状態変更 (例えば、`button pressed` または `button released`) のみをパブリッシュします。

MQTT は、使用できる一般的なパブリッシュおよびサブスクライブのツールの 1 つです。 MQTT ブローカーをエッジ・サービスとしてデプロイし、パブリッシャー・サービスおよびサブスクライバー・サービスがそれを必要とするようにできます。 MQTT は、しばしばクラウド・サービスとしても使用されます。 例えば、IBM Watson IoT Platform は、IoT デバイスとの通信のために MQTT を使用します。 詳しくは、[IBM Watson IoT Platform](https://www.ibm.com/cloud/watson-iot-platform) を参照してください。 一部の {{site.data.keyword.horizon_open}} プロジェクト・サンプルは MQTT を使用します。 詳しくは、『[{{site.data.keyword.horizon_open}} サンプル](https://github.com/open-horizon/examples)』を参照してください。

もう 1 つの一般的なパブリッシュおよびサブスクライブのツールは Apache Kafka であり、これはクラウド・サービスとしても頻繁に使用されます。 `cpu2evtstreams` サンプルがデータを {{site.data.keyword.cloud_notm}} に送信するために使用する {{site.data.keyword.message_hub_notm}} も Kafka に基づいています。 詳しくは、[{{site.data.keyword.message_hub_notm}}](https://www.ibm.com/cloud/event-streams)を参照してください。

どのエッジ・サービス・コンテナーも、同じホスト上の他のローカル・エッジ・サービス、および、ローカル LAN 上の近隣ホスト上で提供されるエッジ・サービスを、提供またはコンシュームできます。 コンテナーは、リモート企業またはクラウド・プロバイダーのデータ・センター内の中央システムと通信することがあります。 サービス作成者は、サービスが通信する相手およびその方法を決定する必要があります。クラウド・プロバイダー・サービスと通信する場合は、[シークレットの作成](developing_secrets.md)の説明に従って、認証資格情報を含むシークレットを使用してください。

もう一度 `cpu2evtstreams` サンプルを検討して、このサンプルのコードが他の 2 つのローカル・サービスをどのように使用しているのかを確認すると役立つかもしれません。 例えば、このサンプル・コードが、どのように、他の 2 つのローカル・サービスへの依存関係を指定し、構成変数を宣言して使用し、Kafka と通信しているのかといったことです。 詳しくは、[`cpu2evtstreams` サンプル](cpu_msg_example.md)を参照してください。

## 特権モードのサービス
{: #priv_services}
ホスト・マシンでは、一部のタスクは root アクセス権限を持つアカウントのみが実行できます。コンテナーでそれに相当するものは特権モードです。通常、コンテナーはホストで特権モードを必要としませんが、特権モードが必要なユース・ケースはいくつか存在します。{{site.data.keyword.ieam}} では、特権プロセス実行が有効になった状態でサービスをデプロイする必要があることを指定できます。デフォルトでは特権プロセス実行は無効になっています。特権モードで実行する必要があるサービスごとに、個別のサービス定義ファイルの[デプロイメント構成](https://open-horizon.github.io/anax/deployment_string.html)で、明示的に特権モードを有効にする必要があります。さらに、そのサービスをデプロイする任意のノードでも、特権モードのコンテナーを明示的に許可する必要があります。これらの操作によって、ノード所有者はそのエッジ・ノードで実行するサービスについて確実に制御することができます。エッジ・ノードで特権モード・ポリシーを有効にする方法の例は、[特権ノードのポリシー](https://github.com/open-horizon/anax/blob/master/cli/samples/privileged_node_policy.json)を参照してください。サービス定義またはその依存関係のいずれかに特権モードが必要な場合、ノード・ポリシーでも特権モードを許可する必要があります。そうしないと、どのサービスもノードにデプロイされません。特権モードについての詳細は、[What is privileged mode and do I need it?](https://wiki.lfedge.org/pages/viewpage.action?pageId=44171856) を参照してください。


## サービス定義
{: #service_definition}

注: コマンド構文について詳しくは、[本書の規則](../getting_started/document_conventions.md)を参照してください。

どの {{site.data.keyword.ieam}} プロジェクトにも 1 つの `horizon/service.definition.json` ファイルがあります。 このファイルは、2 つの目的のためにエッジ・サービスを定義します。 目的の 1 つは、`hzn dev` ツールを使用してサービスの実行をシミュレートできるようにすることです。 このツールは、[ネットワーク・サンドボックス](#sandbox)などの、実際のエージェント環境をシミュレートします。このシミュレーションは、特殊なデプロイメント指示 (ポート結合やハードウェア・デバイス・アクセスなど) が必要な場合にそれを解決するのに役立ちます。 また、エージェントが作成する Docker 仮想プライベート・ネットワーク上のサービス・コンテナー間の通信を検証するためにも、シミュレーションが役立ちます。 このファイルがあるもう 1 つの理由は、サービスを {{site.data.keyword.horizon_exchange}} に公開できるようにすることです。 提供されているサンプルでは、`horizon/service.definition.json` ファイルはサンプルの GitHub リポジトリー内に用意されているか、`hzn dev service new` コマンドによって生成されます。

サービス実装のサンプルの 1 つ (例えば [cpu2evtstreams](https://github.com/open-horizon/examples/blob/master/edge/evtstreams/cpu2evtstreams/horizon/service.definition.json)) 用の {{site.data.keyword.horizon}} メタデータが含まれている `horizon/service.definition.json` ファイルを開いてください。

{{site.data.keyword.horizon}} に公開されるすべてのサービスは、組織内でそのサービスを一意的に識別する名前が必要です。名前は `url` フィールドに設定され、組織名、および実装の特定の `version` およびハードウェアの `arch` と組み合わせると、グローバル固有 ID を形成します。 サービス定義についての詳しい説明は、[Service Definition](https://github.com/open-horizon/anax/blob/master/docs/service_def.md) を参照してください。[cpu2evtstreams](https://github.com/open-horizon/examples/blob/master/edge/evtstreams/cpu2evtstreams/horizon/service.definition.json) の例では、必須のサービスやサービス変数などの基本サービス定義の追加機能を利用しています。

`horizon/service.definition.json` ファイルの `requiredServices` セクションには、このサービスが使用するサービスの依存関係がリストされます。 `hzn dev dependency fetch` ツールを使用すると、このリストに依存関係を追加でき、手動でリストを編集する必要がなくなります。 依存関係の追加後は、エージェントがコンテナーを実行すると、それらの他の `requiredServices` も自動的に実行されるようになります (例えば、`hzn dev service start` を使用したとき、または、このサービスがデプロイされるノードを登録したときなどです)。 必要なサービスについて詳しくは、[Service Definition](https://github.com/open-horizon/anax/blob/master/docs/service_def.md) および [cpu2evtstreams](cpu_msg_example.md) を参照してください。

`userInput` セクションには、サービスがそれ自体を特定のデプロイメント用に構成するために取り込むことができるサービス変数を宣言します。 変数名、データ・タイプ、およびデフォルト値をここに宣言します。さらに、それぞれについて人間が読みやすい説明を指定することもできます。 `hzn dev service start` を使用する場合、またはこのサービスがデプロイされるエッジ・ノードを登録する場合には、これらのサービス変数を構成する必要があります。[cpu2evtstreams](cpu_msg_example.md) の例では、ノード登録中に `userinput.json` ファイルを提供することで、サービス変数の構成を行ないます。CLI コマンド `hzn exchange node update -f <userinput-settings-file>` を使用してリモートからサービス変数を設定することもできます。サービス変数について詳しくは、[Service Definition ](https://github.com/open-horizon/anax/blob/master/docs/service_def.md)および [cpu2evtstreams](cpu_msg_example.md) を参照してください。

`horizon/service.definition.json` ファイルには、ファイルの最後のほうに `deployment` セクションも含まれています。 このセクション内のフィールドは、論理サービスを実装する各 Docker コンテナーの名前を指定します。 ここの `services` 配列内の各コンテナーの名前は、他のコンテナーが共有仮想プライベート・ネットワーク上でコンテナーを識別するために使用する名前です。 他のコンテナーがコンシュームするための REST API をこのコンテナーが提供している場合、`curl http://<name>/<your-rest-api-uri>` を使用して、コンシュームしているコンテナー内でこの REST API にアクセスできます。 各名前の `image` フィールドは、DockerHub 内またはプライベート・コンテナー・レジストリー内などの、対応する Docker コンテナー・イメージへの参照を提供します。 `deployment` セクションで他のフィールドを使用すると、Docker がコンテナーの実行に使用するランタイム・オプションを指定して、コンテナーを構成できます。詳しくは、[{{site.data.keyword.horizon}} deployment 構成](https://github.com/open-horizon/anax/blob/master/docs/deployment_string.md)を参照してください。

## 次の作業
{: #developing_what_next}

エッジ・ノード・コードの開発について詳しくは、以下の資料を参照してください。

* [エッジ・ネイティブ開発プラクティス](best_practices.md)

   {{site.data.keyword.ieam}} ソフトウェア開発用のエッジ・サービスの開発に関する重要な原則およびベスト・プラクティスを確認してください。

* [{{site.data.keyword.cloud_registry}} の使用](container_registry.md)

  {{site.data.keyword.ieam}} では、オプションで、パブリック Docker ハブではなく、IBM のセキュアなプライベート・コンテナー・レジストリーに、サービス・コンテナーを入れることができます。 例えば、パブリック・レジストリーに入れるのが適切でないアセットが含まれているソフトウェア・イメージがある場合、{{site.data.keyword.cloud_registry}} のような、プライベート Docker コンテナー・レジストリーを使用できます。

* [API](../api/index.md)

  {{site.data.keyword.ieam}} は、組織の開発者とユーザーがコンポーネントを連携して制御できるようにするための RESTful API を提供します。

* [ロールバックによるエッジ・サービスの更新](../using_edge_services/service_rollbacks.md)

  既存エッジ・サービスの新しいバージョンをロールアウトする方法のさらなる詳細と、パターンまたはデプロイメント・ポリシーでロールバック設定を更新するためのソフトウェア開発におけるベスト・プラクティスを参照してください。
