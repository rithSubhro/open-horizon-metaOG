---

copyright:
years: 2019
lastupdated: "2019-07-05"

---

{:new_window: target="blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:child: .link .ulchildlink}
{:childlinks: .ullinks}

# 開発の詳細
{: #developing}

ここでは、ソフトウェア開発の慣例および {{site.data.keyword.edge_notm}} ({{site.data.keyword.ieam}}) 開発の概念について詳しく説明します。
{:shortdesc}

## 概要
{: #developing_intro}

{{site.data.keyword.edge_notm}} ({{site.data.keyword.ieam}}) は、[Open Horizon - EdgeX Project Group](https://wiki.edgexfoundry.org/display/FA/Open+Horizon+-+EdgeX+Project+Group) オープン・ソース・ソフトウェアに基づいて作成されています。

{{site.data.keyword.ieam}} を使用して、エッジ・マシン用の任意のサービス・コンテナーを開発できます。 その後、暗号署名を実行し、コードを公開できます。 最後に、{{site.data.keyword.edge_deploy_pattern}}内で、ソフトウェアのインストール、モニター、および更新を制御するためのポリシーを指定できます。 これらのタスクを完了すると、{{site.data.keyword.horizon_agents}}および {{site.data.keyword.horizon_agbots}} がソフトウェア・ライフサイクルの管理についてコラボレーションするという合意を形成していることを確認できます。 これらのコンポーネントは、その後、{{site.data.keyword.edge_nodes}}上のソフトウェア・ライフサイクルの詳細を、各エッジ・ノードの登録済みデプロイメント・パターンに基づいて、完全に自律的に管理します。 {{site.data.keyword.ieam}} は、いつ、どこに、サービスおよび機械学習モデルを自律的にデプロイするのかを、ポリシーを使用して判断することもできます。 ポリシーは、デプロイメント・パターンに代わるものです。

{{site.data.keyword.ieam}} 内でのソフトウェア開発プロセスでは、システムのセキュリティーおよび保全性を維持することに重点が置かれる一方、エッジ・ノード上のアクティブなソフトウェアの管理に必要な作業は大幅に簡略化されます。 {{site.data.keyword.ieam}} は、いつ、どこに、サービスおよび機械学習モデルを自律的にデプロイするのかを、ポリシーを使用して判断することもできます。 ポリシーは、デプロイメント・パターンに代わるものです。 {{site.data.keyword.ieam}} の公開プロシージャーをビルドして、連続的な統合およびデプロイメントのパイプラインに組み込むことができます。 分散自律型エージェントが、ソフトウェアまたはポリシー ({{site.data.keyword.edge_deploy_pattern}}またはデプロイメント・ポリシー内など) に対して公開された変更を検出すると、自律型エージェントは独立して動作し、エッジ・マシンすべてにわたって (マシンがどこにあっても) ソフトウェアを更新したり、ポリシーを適用したりします。

## サービスおよびデプロイメント・パターン
{: #services_deploy_patterns}

{{site.data.keyword.edge_services}}は、デプロイメント・パターンのビルディング・ブロックです。 各サービスは 1 つ以上の Docker コンテナーを含むことができます。 各 Docker コンテナーは、1 つ以上の長時間実行プロセスを含むことができます。 これらのプロセスは、ほとんどすべてのプログラミング言語で作成でき、任意のライブラリーまたはユーティリティーを使用できます。 ただし、これらのプロセスは、Docker コンテナーのコンテキストで開発され、実行される必要があります。 この柔軟性は、{{site.data.keyword.ieam}} が管理できるコードには、ほとんど制約がないことを意味します。 コンテナーが実行されると、そのコンテナーはセキュアなサンドボックス内に閉じ込められます。 このサンドボックスは、ハードウェア・デバイス、いくつかのオペレーティング・システム・サービス、ホスト・ファイル・システム、およびホスト・エッジ・マシン・ネットワークにアクセスを制限します。 サンドボックス制約について詳しくは、『[サンドボックス](#sandbox)』を参照してください。

`cpu2evtstreams` サンプル・コードは、他の 2 つのローカル・エッジ・サービスを使用する 1 つの Docker コンテナーからなります。 これらのローカル・エッジ・サービスは、ローカルのプライベート Docker 仮想ネットワークを介して、HTTP REST API を使用して接続されています。 これらのサービスの名前は、`cpu` と `gps` です。 エージェントは、各サービスを、そのサービスへの依存関係を宣言した各サービスと共に、別々のプライベート・ネットワークにデプロイします。 `cpu2evtstreams` と `cpu` のために 1 つのネットワークが作成され、`cpu2evtstreams` と `gps` のために別のネットワークが作成されます。 このデプロイメント・パターンに 4 番目のサービスがあり、それも `cpu` サービスを共有しているとすると、`cpu` と 4 番目のサービスのためにのみ、もう 1 つのプライベート・ネットワークが作成されます。 {{site.data.keyword.ieam}} では、このネットワーク戦略によって、サービスのアクセスは、他のサービスが公開されたときに `requiredServices` にリストされている他のサービスのみに制限されます。 以下の図は、エッジ・ノードで実行されるときの `cpu2evtstreams` デプロイメント・パターンを示しています。

<img src="../images/edge/07_What_is_an_edge_node.svg" style="margin: 3%" alt="パターンのサービス">

**注**: IBM Event Streams のセットアップは一部のサンプルでのみ必要です。

2 つの仮想ネットワークにより、`cpu2evtstreams` サービス・コンテナーは、`cpu` サービス・コンテナーおよび `gps` サービス・コンテナーによって提供される REST API にアクセスできるようになっています。 これら 2 つのコンテナーは、オペレーティング・システム・サービスおよびハードウェア・デバイスへのアクセスを管理します。 REST API が使用されていますが、複数のサービスでのデータおよびコントロールの共有を可能にするために使用できる、その他の多くの通信形式があります。

多くの場合、エッジ・ノード向けの最も効率的なコーディング・パターンでは、独立して構成可能かつデプロイ可能な複数の小さなサービスがデプロイされます。 例えば、IoT パターンには、多くの場合、エッジ・ノード・ハードウェア (センサーやアクチュエーターなど) へのアクセスを必要とする下位サービスが含まれます。 これらのサービスは、他のサービスが使用できるように、このハードウェアへの共有アクセスを提供します。

このパターンは、有用な機能を提供するためにハードウェアが排他的アクセスを必要とする場合に役立ちます。 下位サービスは、このアクセスを適切に管理できます。 `cpu` サービス・コンテナーおよび `gps` サービス・コンテナーの役割は、基本的にはホストのオペレーティング・システム内のデバイス・ドライバー・ソフトウェアの役割に似ていますが、ただし、より高いレベルでのことです。 コードを分割して、独立した小さなサービス (一部は、ハードウェア・アクセス専門の下位サービス) にすると、問題点を明確に切り分けることができます。 各コンポーネントは自由に進化でき、現場で個別に更新できます。 また、サード・パーティー・アプリケーションを、それらが特定のハードウェアまたは他のサービスにアクセスすることを選択的に許可することによって、お客様専有の従来型の組み込みソフトウェア・スタックと一緒に安全にデプロイすることもできます。

例として、電力消費センサーをモニターするための 1 つの下位サービスとその他の下位サービスから構成される、製造コントローラーのデプロイメント・パターンを考えてみましょう。 それらの他の下位サービスは、モニターされるデバイスの電源操作のためのアクチュエーターの制御を有効にするために使用できます。 このデプロイメント・パターンに、センサーおよびアクチュエーターのサービスをコンシュームする、別の最上位サービス・コンテナーを含めることもできます。 この最上位サービスは、それらのサービスを使用して、オペレーターにアラートを出したり、異常な電力消費計測値が検出されたら自動的にデバイスの電源を切ったりすることができます。 また、このデプロイメント・パターンには、センサーおよびアクチュエーターのデータを記録して保存し、データに関する分析も実行できるような、履歴サービスを含めることもできます。 このようなデプロイメント・パターンに有用だと思われるその他のコンポーネントとして、GPS ロケーション・サービスがあります。

この設計では、個々のサービス・コンテナーを独立して更新することができます。 コード変更を行うことなく、個々のサービスを再構成して他の有用なデプロイメント・パターンに組み入れることもできます。 必要な場合、サード・パーティー分析サービスをパターンに追加できます。 このサード・パーティー・サービスに読み取り専用 API の特定のセットのみへのアクセス権を付与することで、プラットフォーム上のアクチュエーターと対話しないように制限できます。

あるいは、この製造コントローラー例のすべてのタスクを単一のサービス・コンテナー内で実行することもできます。 この代替方法は通常は最善の手法ではありません。なぜなら、相互に接続された独立した小さなサービスの集合を使用するほうが、ソフトウェアの更新が速くなり、柔軟性が増すためです。 現場では小さなサービスの集合のほうがより強固でもあります。 デプロイメント・パターンの設計方法について詳しくは、[エッジ・ネイティブ開発プラクティス](best_practices.md)を参照してください。

## サンドボックス
{: #sandbox}

サービスの実行場所となるサンドボックスは、サービス・コンテナーによって提供される API にアクセスを限定します。 これは、1 つ以上の仮想プライベート・ネットワークに各サービスをデプロイすることで実現されます。 サービスは、明示的にサービスへの依存関係を示している場合のみアクセスを許可されます。 仮想プライベート・ネットワーク上でコンテナーの DNS 名を構成する方法については、[サービス定義](#service_definition)を参照してください。 通常、ホスト上のその他のプロセスは、これらのサービスへのアクセス権を持ちません。 同様に、他のリモート・ホストは通常はこれらのサービスのどれにもアクセスできません。ただし、サービスがホストの外部ネットワーク・インターフェースにポートを明示的に公開している場合を除きます。

## 他のサービスを使用するサービス
{: #using_services}

多くの場合、エッジ・サービスは、他のエッジ・サービスによって提供されるさまざまな API インターフェースを使用して、他のエッジ・サービスからデータを入手したり、それらに制御コマンドを送付したりします。 これらの API インターフェースは、`cpu2evtstreams` サンプルの下位サービス `cpu` および `gps` によって提供されているように、HTTP REST API であるのが一般的です。 ただし、これらのインターフェースは実際には、任意のもの (例えば、共有メモリー、TCP、または UDP) にすることができ、暗号化の有無も任意です。 これらの通信は、通常、単一のエッジ・ノード内で行われ、メッセージがこのホストを離れることはないため、ほとんどの場合は暗号化は不要です。

REST API の代わりに、パブリッシュ/サブスクライブのインターフェース (例えば、MQTT によって提供されるインターフェース) を使用できます。 データを断続的にしか提供しないサービスの場合、REST API はタイムアウトになる可能性があるため、通常はパブリッシュ/サブスクライブのインターフェースのほうが REST API を繰り返しポーリングするよりも単純です。 例として、ハードウェア・ボタンをモニターし、ボタン押下が発生したかどうかを他のサービスが検出できるように API を提供するサービスを考えてみましょう。 REST API が使用される場合、呼び出し元はその REST API を呼び出し、ボタンが押されたときに生じる応答を待てばいいわけではありません。 ボタンが押されないまま長時間経過すると、REST API はタイムアウトになります。 代わりに、エラーを回避するために、API の提供側が即時に応答することが必要になります。 呼び出し元は、短いボタン押下を見逃さないために、繰り返し、頻繁に API を呼び出さなければなりません。 より良い解決方法は、呼び出し元が、パブリッシュとサブスクライブを行うサービスおよびブロックに対して適切なトピックをサブスクライブすることです。 そうすると、呼び出し元は何かがパブリッシュされるのを待つことができ、それはずっと先に起こる可能性があります。 API の提供側では、ボタン・ハードウェアをモニターし、そのトピックの状態変更 (例えば、`button pressed` または `button released`) のみをパブリッシュします。

MQTT は、使用できる一般的なパブリッシュおよびサブスクライブのツールの 1 つです。 MQTT ブローカーをエッジ・サービスとしてデプロイし、パブリッシャー・サービスおよびサブスクライバー・サービスがそれを必要とするようにできます。 MQTT は、しばしばクラウド・サービスとしても使用されます。 例えば、IBM Watson IoT Platform は、IoT デバイスとの通信のために MQTT を使用します。 詳しくは、[IBM Watson IoT Platform](https://www.ibm.com/cloud/watson-iot-platform) を参照してください。 一部の {{site.data.keyword.horizon_open}} プロジェクト・サンプルは MQTT を使用します。 詳しくは、『[{{site.data.keyword.horizon_open}} サンプル](https://github.com/open-horizon/examples)』を参照してください。

もう 1 つの一般的なパブリッシュおよびサブスクライブのツールは Apache Kafka であり、これはクラウド・サービスとしても頻繁に使用されます。 `cpu2evtstreams` サンプルがデータを {{site.data.keyword.cloud_notm}} に送信するために使用する {{site.data.keyword.message_hub_notm}} も Kafka に基づいています。 詳しくは、[{{site.data.keyword.message_hub_notm}}](https://www.ibm.com/cloud/event-streams)を参照してください。

どのエッジ・サービス・コンテナーも、同じホスト上の他のローカル・エッジ・サービス、および、ローカル LAN 上の近隣ホスト上で提供されるエッジ・サービスを、提供またはコンシュームできます。 コンテナーは、リモート企業またはクラウド・プロバイダーのデータ・センター内の中央システムと通信することがあります。 サービス作成者は、サービスが通信する相手およびその方法を決定する必要があります。

もう一度 `cpu2evtstreams` サンプルを検討して、このサンプルのコードが他の 2 つのローカル・サービスをどのように使用しているのかを確認すると役立つかもしれません。 例えば、このサンプル・コードが、どのように、他の 2 つのローカル・サービスへの依存関係を指定し、構成変数を宣言して使用し、Kafka と通信しているのかといったことです。 詳しくは、[`cpu2evtstreams` サンプル](cpu_msg_example.md)を参照してください。

## サービス定義
{: #service_definition}

**注**: コマンド構文について詳しくは、[本書の規則](../getting_started/document_conventions.md)を参照してください。

どの {{site.data.keyword.ieam}} プロジェクトにも 1 つの `horizon/service.definition.json` ファイルがあります。 このファイルは、2 つの理由のためにエッジ・サービスを定義します。 理由の 1 つは、{{site.data.keyword.horizon_agent}} でサービスが実行されるのと同じように、`hzn dev` ツールによってサービスの実行をシミュレートできるようにすることです。 このシミュレーションは、特殊なデプロイメント指示 (ポート結合やハードウェア・デバイス・アクセスなど) が必要な場合にそれを解決するのに役立ちます。 また、エージェントが作成する Docker 仮想プライベート・ネットワーク上のサービス・コンテナー間の通信を検証するためにも、シミュレーションが役立ちます。 このファイルがあるもう 1 つの理由は、サービスを {{site.data.keyword.horizon_exchange}} に公開できるようにすることです。 提供されているサンプルでは、`horizon/service.definition.json` ファイルはサンプルの GitHub リポジトリー内に用意されているか、`hzn dev service new` コマンドによって生成されます。

サービス実装のサンプルの 1 つ (例えば [cpu2evtstreams](https://github.com/open-horizon/examples/blob/master/edge/evtstreams/cpu2evtstreams/horizon/service.definition.json)) 用の {{site.data.keyword.horizon}} メタデータが含まれている `horizon/service.definition.json` ファイルを開いてください。

{{site.data.keyword.horizon}} に公開されるすべてのサービスは、組織内でそのサービスを一意的に識別する `url` を持っている必要があります。 このフィールドは URL ではありません。 この `url` フィールドは、組織名、および実装の特定の `version` フィールドおよび `arch` フィールドと組み合わせられた場合、グローバルに固有の ID を形成します。 `horizon/service.definition.json` ファイルを編集して、`url` および `version` に適切な値を設定できます。 `version` 値には、何らかの意味体系に沿ったバージョン管理スタイル値を使用してください。 サービス・コンテナーのプッシュ、署名、および公開を行うときに、これらの新しい値を使用します。 あるいは、`horizon/hzn.json` ファイルを編集できます。ツールにより、 `horizon/service.definition.json` ファイル内で使用されている変数参照の代わりに、そこで見つかった変数値が使用されます。

`horizon/service.definition.json` ファイルの `requiredServices` セクションには、このコンテナーが使用する他のエッジ・サービスなど、サービス依存関係がリストされます。 `hzn dev dependency fetch` ツールを使用すると、このリストに依存関係を追加でき、手動でリストを編集する必要がなくなります。 依存関係の追加後は、エージェントがコンテナーを実行すると、それらの他の `requiredServices` も自動的に実行されるようになります (例えば、`hzn dev service start` を使用したとき、または、このサービスを含んでいるデプロイメント・パターンにノードを登録したときなどです)。 必要なサービスについて詳しくは、[cpu2evtstreams](cpu_msg_example.md) を参照してください。

`userInput` セクションには、サービスがそれ自体を特定のデプロイメント用に構成するためにコンシュームできる構成変数を宣言します。 変数名、データ・タイプ、およびデフォルト値をここに指定します。さらに、それぞれについて人間が読みやすい説明を指定することもできます。 `hzn dev service start` を使用するとき、または、このサービスを含んでいるデプロイメント・パターンにエッジ・ノードを登録するときには、デフォルト値が設定されていない変数の値を定義する `userinput.json` ファイルを提供する必要があります。 `userInput` 構成変数および `userinput.json` ファイルについて詳しくは、[cpu2evtstreams](cpu_msg_example.md) を参照してください。

`horizon/service.definition.json` ファイルには、ファイルの最後のほうに `deployment` セクションも含まれています。 deployment セクションには、論理サービスを実装する各コンテナー・イメージの DNS 名と構成を定義する `services` と呼ばれるマップが含まれています。 `services` マップで定義されている各サービスの DNS 名は、コンテナー構成を定義するマップ・キーと同じです。 DNS 名は、このコンテナーによってホストされるリモート API を開始するために他のコンテナーによって使用されます。 各コンテナーの DNS 名は、コラボレーションするコンテナーのグループ内で固有である必要があります。 例えば、このコンテナーが、他のコンテナーがコンシュームするための REST API を提供する場合、他のコンテナーのアプリケーションは `curl http://<dns-name>/<your-rest-api-uri>` を使用して、この REST API を開始できます。 DNS 名の固有性が保証されない場合、同じプライベート仮想ネットワーク上で競合する名前を持つコンテナーによってホストされるリモート API にアクセスすると、非決定的動作が発生します。 各名前の `image` フィールドは、DockerHub 内またはプライベート・コンテナー・レジストリー内などの、対応する Docker コンテナー・イメージへの参照を提供します。 `deployment` セクションの他のフィールドを使用して、エージェントが Docker にコンテナーを実行するよう指示する方法を変更できます。 詳しくは、[{{site.data.keyword.horizon}} deployment 構成](https://github.com/open-horizon/anax/blob/master/docs/deployment_string.md)を参照してください。

## 次の作業
{: #developing_what_next}

エッジ・ノード・コードの開発について詳しくは、以下の資料を参照してください。

* [エッジ・ネイティブ開発プラクティス](best_practices.md)

   {{site.data.keyword.ieam}} ソフトウェア開発用のエッジ・サービスの開発に関する重要な原則およびベスト・プラクティスを確認してください。

* [{{site.data.keyword.cloud_registry}} の使用](container_registry.md)

  {{site.data.keyword.ieam}} では、オプションで、パブリック Docker ハブではなく、IBM のセキュアなプライベート・コンテナー・レジストリーに、サービス・コンテナーを入れることができます。 例えば、パブリック・レジストリーに入れるのが適切でないアセットが含まれているソフトウェア・イメージがある場合、{{site.data.keyword.cloud_registry}} のような、プライベート Docker コンテナー・レジストリーを使用できます。

* [API](../api/edge_rest_apis.md)

  {{site.data.keyword.ieam}} は、組織の開発者とユーザーがコンポーネントを連携して制御できるようにするための RESTful API を提供します。

* [ロールバックによるエッジ・サービスの更新](../using_edge_services/service_rollbacks.md)

  既存エッジ・サービスの新しいバージョンをロールアウトする方法のさらなる詳細と、パターンまたはデプロイメント・ポリシーでロールバック設定を更新するためのソフトウェア開発におけるベスト・プラクティスを参照してください。
